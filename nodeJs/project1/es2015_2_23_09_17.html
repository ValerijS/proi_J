<!DOCTYPE html>
<html>
 <!--
 http://es6-features.org/#Constants
http://es6-features.org/#ValueExportImport
 -->
<body>
<p id="demo"></p>
<p id="demo1"></p>
<script>
 /*
 //Block-scoped function definitions.

//{
//    function foo () { return 1 }
//    foo() === 1
//    {
//        function foo () { return 2 }
//        foo() === 2
//     document.getElementById("demo1").innerHTML = foo() === 2;//true
//
//    }
//    foo() === 1//true
//}
 */
 /*
//Support for constants (also known as "immutable variables"), i.e., variables which cannot be re-assigned new content. Notice: this only makes the variable itself immutable, not its assigned content (for instance, in case the content is an object, this means the object itself can still be altered).
//const PI = 3.141593
//PI > 3.0
 */
/* 
// Arrow Functions
//Expression Bodies
//More expressive closure syntax
// odds  = evens.map(v => v + 1)
//pairs = evens.map(v => ({ even: v, odd: v + 1 }))
//nums  = evens.map((v, i) => v + i)
 
// Arrow Functions
//Statement Bodies
//More expressive closure syntax
//nums.forEach(function (v) {
//   if (v % 5 === 0)
//       fives.push(v); 
*/ 
 /*
// Lexical this
//More intuitive handling of current object context.
 //this did not work without function around(pr())
// let bob = 
//     {
//         _nums: [0,1,5,7,15],
//         _fives: [],
//     //console.log('a1',this[nums]);
//     pr(){      
//        this._nums.forEach((v)=> {
//              if (v % 5 === 0)
//                  this._fives.push(v)
//        })
//      }
//     }
// bob.pr()
// let v = bob._fives;
// document.getElementById("demo1").innerHTML = v;
// 
 
// let bob = 
//     {
//         _nums: [0,1,5,7,15],
//         _fives: []
//     }
//         bob._nums.forEach((v) => {
//            if (v % 5 === 0)
//                bob._fives.push(v)
//
//        })
//     
// let v = bob._fives;
// document.getElementById("demo1").innerHTML = v;
 //
 */
 /*
 Extended Parameter Handling
Default Parameter Values
Simple and intuitive default values for function parameters.
 function f (x, y = 7, z = 42) {
    return x + y + z
}
f(1) === 50
document.getElementById("demo").innerHTML = f(1) === 50;//True
 */
/* 
// Aggregation of remaining arguments into single parameter of variadic functions.
//ECMAScript 6 — syntactic sugar: reduced | traditional
function f (x, y, ...a) {
    return (x + y) * a.length
}
f(1, 2, "hello", true, 7) === 9
 
 document.getElementById("demo").innerHTML = f(1, 2, "hello", true, 7) === 9;//true
 */
 /*
// Extended Parameter Handling
//Spread Operator
//Spreading of elements of an iterable collection (like an array or even a string) into both literal elements and individual function parameters.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var params = [ "hello", true, 7 ]
var other = [ 1, 2, ...params ] // [ 1, 2, "hello", true, 7 ]

function f (x, y, ...a) {
    return (x + y) * a.length
}
f(1, 2, ...params) === 9

var str = "foo"
var chars = [ ...str ] // [ "f", "o", "o" ]
 document.getElementById("demo").innerHTML = chars;
//ECMAScript 5 — syntactic sugar: reduced | traditional
var params = [ "hello", true, 7 ];
var other = [ 1, 2 ].concat(params); // [ 1, 2, "hello", true, 7 ]

function f (x, y) {
    var a = Array.prototype.slice.call(arguments, 2);
    return (x + y) * a.length;
};
f.apply(undefined, [ 1, 2 ].concat(params)) === 9;

var str = "foo";
var chars = str.split(""); // [ "f", "o", "o" ]
 document.getElementById("demo1").innerHTML = chars;
 */ 
 /* 
// Enhanced Object Properties
//Property Shorthand
//Shorter syntax for common object property definition idiom.
//ECMAScript 6 — syntactic sugar: reduced | traditional
obj = { x, y }
//ECMAScript 5 — syntactic sugar: reduced | traditional
obj = { x: x, y: y }; 
 */
 /*
 Enhanced Object Properties
Computed Property Names
Support for computed names in object property definitions.
ECMAScript 6 — syntactic sugar: reduced | traditional
let obj = {
    foo: "bar",
    [ "baz" + quux() ]: 42
}
ECMAScript 5 — syntactic sugar: reduced | traditional
var obj = {
    foo: "bar"
};
obj[ "baz" + quux() ] = 42;
 */
 /*
// Enhanced Object Properties
//Method Properties
//Support for method notation in object property definitions, for both regular functions and generator functions.
//ECMAScript 6 — syntactic sugar: reduced | traditional
obj = {
    foo (a, b) {
        …
    },
    bar (x, y) {
        …
    },
    *quux (x, y) {
        …
    }
}
//ECMAScript 5 — syntactic sugar: reduced | traditional
obj = {
    foo: function (a, b) {
        …
    },
    bar: function (x, y) {
        …
    },
    //  quux: no equivalent in ES5
    …
};
 */
 /*
// Destructuring Assignment
//Array Matching
//Intuitive and flexible destructuring of Arrays into individual variables during assignment.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var list = [ 1, 2, 3 ]
var [ a, , b ] = list
[ b, a ] = [ a, b ]
//ECMAScript 5 — syntactic sugar: reduced | traditional
var list = [ 1, 2, 3 ];
var a = list[0], b = list[2];
var tmp = a; a = b; b = tmp;
*/
 /*
// Destructuring Assignment
//Object Matching, Shorthand Notation
//Intuitive and flexible destructuring of Objects into individual variables during assignment.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var { op, lhs, rhs } = getASTNode()
//ECMAScript 5 — syntactic sugar: reduced | traditional
var tmp = getASTNode();
var op  = tmp.op;
var lhs = tmp.lhs;
var rhs = tmp.rhs;
 */
 /*
// Destructuring Assignment
//Object Matching, Deep Matching
//Intuitive and flexible destructuring of Objects into individual variables during assignment.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var { op: a, lhs: { op: b }, rhs: c } = getASTNode()
//ECMAScript 5 — syntactic sugar: reduced | traditional
var tmp = getASTNode();
var a = tmp.op;
var b = tmp.lhs.op;
var c = tmp.rhs;
*/ 
/* 
// Destructuring Assignment
//Object And Array Matching, Default Values
//Simple and intuitive default values for destructuring of Objects and Arrays.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var obj = { a: 1 }
var list = [ 1 ]
var { a, b = 2 } = obj
var [ x, y = 2 ] = list
//ECMAScript 5 — syntactic sugar: reduced | traditional
var obj = { a: 1 };
var list = [ 1 ];
var a = obj.a;
var b = obj.b === undefined ? 2 : obj.b;
var x = list[0];
var y = list[1] === undefined ? 2 : list[1];
 */
 /*
 Destructuring Assignment
Parameter Context Matching
Intuitive and flexible destructuring of Arrays and Objects into individual parameters during function calls.
ECMAScript 6 — syntactic sugar: reduced | traditional
function f ([ name, val ]) {
    console.log(name, val)
}
function g ({ name: n, val: v }) {
    console.log(n, v)
}
function h ({ name, val }) {
    console.log(name, val)
}
f([ "bar", 42 ])
g({ name: "foo", val:  7 })
h({ name: "bar", val: 42 })
//ECMAScript 5 — syntactic sugar: reduced | traditional
function f (arg) {
    var name = arg[0];
    var val  = arg[1];
    console.log(name, val);
};
function g (arg) {
    var n = arg.name;
    var v = arg.val;
    console.log(n, v);
};
function h (arg) {
    var name = arg.name;
    var val  = arg.val;
    console.log(name, val);
};
f([ "bar", 42 ]);
g({ name: "foo", val:  7 });
h({ name: "bar", val: 42 });
 */
/* 
// Destructuring Assignment
//Fail-Soft Destructuring
//Fail-soft destructuring, optionally with defaults.
//ECMAScript 6 — syntactic sugar: reduced | traditional
var list = [ 7, 42 ]
var [ a = 1, b = 2, c = 3, d ] = list
a === 7
b === 42
c === 3
d === undefined
//ECMAScript 5 — syntactic sugar: reduced | traditional
var list = [ 7, 42 ];
var a = typeof list[0] !== "undefined" ? list[0] : 1;
var b = typeof list[1] !== "undefined" ? list[1] : 2;
var c = typeof list[2] !== "undefined" ? list[2] : 3;
var d = typeof list[3] !== "undefined" ? list[3] : undefined;
a === 7;
b === 42;
c === 3;
d === undefined;
 */
 /*
// Modules
//Value Export/Import
//Support for exporting/importing values from/to modules without global namespace pollution.
//ECMAScript 6 — syntactic sugar: reduced | traditional
//  lib/math.js
export function sum (x, y) { return x + y }
export var pi = 3.141593

//  someApp.js
import * as math from "lib/math"
console.log("2π = " + math.sum(math.pi, math.pi))

//  otherApp.js
import { sum, pi } from "lib/math"
console.log("2π = " + sum(pi, pi))
//ECMAScript 5 — syntactic sugar: reduced | traditional
//  lib/math.js
LibMath = {};
LibMath.sum = function (x, y) { return x + y };
LibMath.pi = 3.141593;

//  someApp.js
var math = LibMath;
console.log("2π = " + math.sum(math.pi, math.pi));

//  otherApp.js
var sum = LibMath.sum, pi = LibMath.pi;
console.log("2π = " + sum(pi, pi));
 */
 /*
// Modules
//Default & Wildcard
//Marking a value as the default exported value and mass-mixin of values.
//ECMAScript 6 — syntactic sugar: reduced | traditional
//  lib/mathplusplus.js
export * from "lib/math"
export var e = 2.71828182846
export default (x) => Math.exp(x)

//  someApp.js
import exp, { pi, e } from "lib/mathplusplus"
console.log("e^{π} = " + exp(pi))
//ECMAScript 5 — syntactic sugar: reduced | traditional
//  lib/mathplusplus.js
LibMathPP = {};
for (symbol in LibMath)
    if (LibMath.hasOwnProperty(symbol))
        LibMathPP[symbol] = LibMath[symbol];
LibMathPP.e = 2.71828182846;
LibMathPP.exp = function (x) { return Math.exp(x) };

//  someApp.js
var exp = LibMathPP.exp, pi = LibMathPP.pi, e = LibMathPP.e;
console.log("e^{π} = " + exp(pi)
 */
 
// Classes
//Class Definition
//More intuitive, OOP-style and boilerplate-free classes.
//ECMAScript 6 — syntactic sugar: reduced | traditional
class Shape {
    constructor (id,x,y) {
        this.id = id
        this.move(x, y)
    }
    move (x, y) {
        this.x = x
        this.y = y
    }
}
//ECMAScript 5 — syntactic sugar: reduced | traditional
//var Shape = function (id, x, y) {
//    this.id = id;
//    this.move(x, y);
//};
//Shape.prototype.move = function (x, y) {
//    this.x = x;
 obj = new Shape('key');
 obj.move(33,77)
 document.getElementById("demo").innerHTML =  [obj.id,obj.x,obj.y] ;
 
 
// Classes
//Class Inheritance
//More intuitive, OOP-style and boilerplate-free inheritance.
//ECMAScript 6 — syntactic sugar: reduced | traditional
class Rectangle extends Shape {
    constructor (id, x, y, width, height) {
        super(id, x, y)
        this.width  = width
        this.height = height
    }
}
class Circle extends Shape {
    constructor (id, x, y, radius) {
        super(id, x, y)
        this.radius = radius
    }
}
obj = new Circle('key','valX','valY', 3);
 document.getElementById("demo1").innerHTML =  [obj.id,obj.x,obj.y,obj.radius ] ;
 //obj.move(33,77) 
//ECMAScript 5 — syntactic sugar: reduced | traditional
//var Rectangle = function (id, x, y, width, height) {
//    Shape.call(this, id, x, y);
//    this.width  = width;
//    this.height = height;
//};
//Rectangle.prototype = Object.create(Shape.prototype);
//Rectangle.prototype.constructor = Rectangle;
//var Circle = function (id, x, y, radius) {
//    Shape.call(this, id, x, y);
//    this.radius = radius;
//};
//Circle.prototype = Object.create(Shape.prototype);
//Circle.prototype.constructor = Circle;

 
// Iterators
//Iterator & For-Of Operator
//Support "iterable" protocol to allow objects to customize their iteration behaviour. Additionally, support "iterator" protocol to produce sequence of values (either finite or infinite). Finally, provide convenient of operator to iterate over all values of an iterable object.
//ECMAScript 6 — syntactic sugar: reduced | traditional
let fibonacci = {
    [Symbol.iterator]() {
        let pre = 0, cur = 1
        return {
           next () {
               [ pre, cur ] = [ cur, pre + cur ]
               return { done: false, value: cur }
           }
        }
    }
}

for (let n of fibonacci) {
    if (n > 100)
        break
    console.log(n)
}
 console.log(fibonacci);
//document.getElementById("demo1").innerHTML =  fibonacci;
//ECMAScript 5 — syntactic sugar: reduced | traditional
//var fibonacci = {
//    next: (function () {
//        var pre = 0, cur = 1;
//        return function () {
//            tmp = pre;
//            pre = cur;
//            cur += tmp;
//            return cur;
//        };
//    })()
//};
//
//var n;
//for (;;) {
//    n = fibonacci.next();
//    if (n > 1000)
//        break;
//    console.log(n);
//}
// 
 //console.log('w1',inst);
</script>

</body>
</html>
